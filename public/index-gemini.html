<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gemini Kinetic Particles</title>

    <script src="https://cdn.tailwindcss.com"></script>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #050505;
        font-family: "Inter", sans-serif;
      }
      canvas {
        display: block;
      }

      /* Glassmorphism Utilities */
      .glass {
        background: rgba(255, 255, 255, 0.05);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
      }

      .input-glass {
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: white;
      }

      /* Loading Spinner */
      .loader {
        border: 4px solid rgba(255, 255, 255, 0.1);
        border-left-color: #4f46e5;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* MediaPipe Video mirror */
      #webcam-preview {
        transform: scaleX(-1);
        object-fit: cover;
      }
    </style>
  </head>
  <body class="text-white">
    <canvas id="canvas-container" class="absolute inset-0 z-0"></canvas>

    <video id="input-video" class="hidden" playsinline></video>

    <div
      class="absolute inset-0 z-10 pointer-events-none flex flex-col justify-between p-6"
    >
      <div class="flex justify-between items-start pointer-events-auto">
        <div class="glass px-4 py-2 rounded-lg flex items-center gap-3">
          <div
            id="gesture-indicator"
            class="w-3 h-3 rounded-full bg-red-500 shadow-[0_0_10px_red]"
          ></div>
          <div>
            <div class="text-xs text-gray-400 uppercase tracking-wider">
              Detected Gesture
            </div>
            <div id="gesture-text" class="text-lg font-bold text-white">
              Initializing...
            </div>
          </div>
        </div>

        <div class="flex gap-2">
          <button
            onclick="toggleFullScreen()"
            class="glass hover:bg-white/10 transition p-2 rounded-lg"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              class="h-6 w-6"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 4l-5-5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"
              />
            </svg>
          </button>
        </div>
      </div>

      <div class="flex justify-between items-end pointer-events-auto">
        <div class="glass p-4 rounded-lg max-w-sm">
          <h3 class="text-sm font-bold mb-2 text-gray-300">Gesture Guide</h3>
          <ul class="text-xs space-y-1 text-gray-400">
            <li>
              üñê <span class="text-white">Open Hand:</span> Rainbow Sphere
            </li>
            <li>‚úä <span class="text-white">Fist:</span> Saturn Ring</li>
            <li>
              üëå <span class="text-white">Pinch (Index+Thumb):</span> Heart
              Shape
            </li>
            <li>
              ü§ô <span class="text-white">Pinky (Call Me):</span> "I LOVE YOU"
            </li>
          </ul>
        </div>

        <div class="glass p-1 rounded-lg overflow-hidden w-48 h-36 relative">
          <video
            id="webcam-preview"
            autoplay
            playsinline
            muted
            class="w-full h-full bg-black"
          ></video>
          <div class="absolute bottom-1 right-2 text-[10px] text-white/50">
            Webcam
          </div>
        </div>
      </div>
    </div>

    <div
      id="loading-overlay"
      class="fixed inset-0 z-50 bg-black flex flex-col items-center justify-center transition-opacity duration-500"
    >
      <div class="loader mb-4"></div>
      <div class="text-xl font-mono text-white animate-pulse">
        Booting Neural Particle Engine...
      </div>
      <div id="loading-status" class="text-sm text-gray-500 mt-2">
        Loading Libraries
      </div>
    </div>

    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"
      crossorigin="anonymous"
    ></script>

    <script type="module">
      import * as THREE from "three";
      import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
      import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
      import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
      import { FontLoader } from "three/addons/loaders/FontLoader.js";
      import { TextGeometry } from "three/addons/geometries/TextGeometry.js";
      import { MeshSurfaceSampler } from "three/addons/math/MeshSurfaceSampler.js";

      // --- Configuration ---
      const PARTICLE_COUNT = 20000;
      const CAM_Z = 35;
      const FONT_URL =
        "https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json";

      // --- State ---
      let scene, camera, renderer, composer;
      let particles, geometry, material;
      let positions, colors; // Float32Arrays for BufferAttribute
      let targetPositions = new Float32Array(PARTICLE_COUNT * 3);
      let targetColors = new Float32Array(PARTICLE_COUNT * 3);
      let currentGesture = "None";

      // Cache for pre-calculated shapes
      const shapes = {
        sphere: {
          pos: new Float32Array(PARTICLE_COUNT * 3),
          col: new Float32Array(PARTICLE_COUNT * 3),
        },
        saturn: {
          pos: new Float32Array(PARTICLE_COUNT * 3),
          col: new Float32Array(PARTICLE_COUNT * 3),
        },
        heart: {
          pos: new Float32Array(PARTICLE_COUNT * 3),
          col: new Float32Array(PARTICLE_COUNT * 3),
        },
        text: {
          pos: new Float32Array(PARTICLE_COUNT * 3),
          col: new Float32Array(PARTICLE_COUNT * 3),
        }, // Will load async
      };

      // DOM Elements
      const statusEl = document.getElementById("loading-status");
      const overlayEl = document.getElementById("loading-overlay");
      const gestureText = document.getElementById("gesture-text");
      const gestureInd = document.getElementById("gesture-indicator");

      // --- Initialization ---
      async function init() {
        initThree();
        await precomputeShapes();
        initMediaPipe();
        animate();

        // Hide Loader
        overlayEl.style.opacity = "0";
        setTimeout(() => overlayEl.remove(), 500);
      }

      function initThree() {
        const container = document.getElementById("canvas-container");

        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.001);

        camera = new THREE.PerspectiveCamera(
          50,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.z = CAM_Z;

        renderer = new THREE.WebGLRenderer({
          canvas: container,
          alpha: true,
          antialias: true,
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // Post Processing (Bloom)
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          1.5,
          0.4,
          0.85
        );
        bloomPass.threshold = 0;
        bloomPass.strength = 1.2; // Neon glow intensity
        bloomPass.radius = 0.5;

        composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // Particles Setup
        geometry = new THREE.BufferGeometry();
        positions = new Float32Array(PARTICLE_COUNT * 3);
        colors = new Float32Array(PARTICLE_COUNT * 3);

        // Init particles at random positions
        for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
          positions[i] = (Math.random() - 0.5) * 100;
          colors[i] = Math.random();
        }

        geometry.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );
        geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

        material = new THREE.PointsMaterial({
          size: 0.15,
          vertexColors: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
          transparent: true,
          opacity: 0.8,
        });

        particles = new THREE.Points(geometry, material);
        scene.add(particles);

        window.addEventListener("resize", onWindowResize);
      }

      // --- Shape Logic ---

      async function precomputeShapes() {
        statusEl.innerText = "Generating Math Geometries...";

        // 1. Rainbow Sphere (Open Hand)
        for (let i = 0; i < PARTICLE_COUNT; i++) {
          const r = 10 + Math.random() * 0.5;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);

          const x = r * Math.sin(phi) * Math.cos(theta);
          const y = r * Math.sin(phi) * Math.sin(theta);
          const z = r * Math.cos(phi);

          const idx = i * 3;
          shapes.sphere.pos[idx] = x;
          shapes.sphere.pos[idx + 1] = y;
          shapes.sphere.pos[idx + 2] = z;

          // Rainbow colors based on position
          const color = new THREE.Color().setHSL((y + 10) / 20, 1.0, 0.5);
          shapes.sphere.col[idx] = color.r;
          shapes.sphere.col[idx + 1] = color.g;
          shapes.sphere.col[idx + 2] = color.b;
        }

        // 2. Saturn (Fist)
        for (let i = 0; i < PARTICLE_COUNT; i++) {
          const idx = i * 3;
          const isRing = i > PARTICLE_COUNT * 0.3; // 70% ring, 30% planet

          if (!isRing) {
            // Planet Body (Blue Sphere)
            const r = 6;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            shapes.saturn.pos[idx] = r * Math.sin(phi) * Math.cos(theta);
            shapes.saturn.pos[idx + 1] = r * Math.sin(phi) * Math.sin(theta);
            shapes.saturn.pos[idx + 2] = r * Math.cos(phi);

            // Blueish colors
            shapes.saturn.col[idx] = 0.1;
            shapes.saturn.col[idx + 1] = 0.3;
            shapes.saturn.col[idx + 2] = 0.8 + Math.random() * 0.2;
          } else {
            // Rings (Disk)
            const angle = Math.random() * Math.PI * 2;
            const dist = 9 + Math.random() * 6; // Ring radius 9 to 15

            // Tilt the ring
            const x = dist * Math.cos(angle);
            const z = dist * Math.sin(angle);
            const y = 0;

            // Apply tilt rotation around X axis (approx 30 deg)
            const tilt = 0.5;
            const ry = y * Math.cos(tilt) - z * Math.sin(tilt);
            const rz = y * Math.sin(tilt) + z * Math.cos(tilt);

            shapes.saturn.pos[idx] = x;
            shapes.saturn.pos[idx + 1] = ry;
            shapes.saturn.pos[idx + 2] = rz;

            // Beige/Gold
            shapes.saturn.col[idx] = 0.8;
            shapes.saturn.col[idx + 1] = 0.7;
            shapes.saturn.col[idx + 2] = 0.4;
          }
        }

        // 3. Heart (Pinch/V-Sign)
        for (let i = 0; i < PARTICLE_COUNT; i++) {
          const idx = i * 3;
          // Parametric heart
          // x = 16sin^3(t)
          // y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
          let t = Math.random() * Math.PI * 2;
          // Add some thickness using random offset
          let scale = 0.5;
          let x = 16 * Math.pow(Math.sin(t), 3);
          let y =
            13 * Math.cos(t) -
            5 * Math.cos(2 * t) -
            2 * Math.cos(3 * t) -
            Math.cos(4 * t);
          let z = (Math.random() - 0.5) * 5; // Thickness

          shapes.heart.pos[idx] = x * scale;
          shapes.heart.pos[idx + 1] = y * scale + 2; // Move up slightly
          shapes.heart.pos[idx + 2] = z;

          // Pink
          shapes.heart.col[idx] = 1.0;
          shapes.heart.col[idx + 1] = 0.05;
          shapes.heart.col[idx + 2] = 0.5;
        }

        // 4. Text "I LOVE YOU" (Pinky)
        statusEl.innerText = "Loading 3D Fonts...";
        await new Promise((resolve) => {
          const loader = new FontLoader();
          loader.load(FONT_URL, function (font) {
            const textGeo = new TextGeometry("I LOVE YOU", {
              font: font,
              size: 4,
              height: 1, // depth
              curveSegments: 12,
            });

            textGeo.computeBoundingBox();
            const centerOffset =
              -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);
            textGeo.translate(centerOffset, 0, 0);

            // Use Sampler to get points ON the text surface
            const material = new THREE.MeshBasicMaterial();
            const mesh = new THREE.Mesh(textGeo, material);
            const sampler = new MeshSurfaceSampler(mesh).build();

            const tempPos = new THREE.Vector3();
            for (let i = 0; i < PARTICLE_COUNT; i++) {
              sampler.sample(tempPos);
              const idx = i * 3;
              shapes.text.pos[idx] = tempPos.x;
              shapes.text.pos[idx + 1] = tempPos.y;
              shapes.text.pos[idx + 2] = tempPos.z;

              // Gold
              shapes.text.col[idx] = 1.0;
              shapes.text.col[idx + 1] = 0.84;
              shapes.text.col[idx + 2] = 0.0;
            }
            resolve();
          });
        });

        // Set initial target to Sphere
        transitionToShape("sphere");
      }

      function transitionToShape(shapeName) {
        // Deep copy target arrays
        targetPositions.set(shapes[shapeName].pos);
        targetColors.set(shapes[shapeName].col);
      }

      // --- Animation Loop ---
      const clock = new THREE.Clock();

      function animate() {
        requestAnimationFrame(animate);

        const delta = clock.getDelta();
        const time = clock.getElapsedTime();

        const posAttr = geometry.attributes.position;
        const colAttr = geometry.attributes.color;

        // Lerp loop
        for (let i = 0; i < PARTICLE_COUNT; i++) {
          const idx = i * 3;

          // Smoothly interpolate positions
          // Speed depends on gesture (slower for detailed shapes like text)
          const lerpSpeed = 3.0 * delta;

          posAttr.array[idx] +=
            (targetPositions[idx] - posAttr.array[idx]) * lerpSpeed;
          posAttr.array[idx + 1] +=
            (targetPositions[idx + 1] - posAttr.array[idx + 1]) * lerpSpeed;
          posAttr.array[idx + 2] +=
            (targetPositions[idx + 2] - posAttr.array[idx + 2]) * lerpSpeed;

          // Smoothly interpolate colors
          colAttr.array[idx] +=
            (targetColors[idx] - colAttr.array[idx]) * lerpSpeed;
          colAttr.array[idx + 1] +=
            (targetColors[idx + 1] - colAttr.array[idx + 1]) * lerpSpeed;
          colAttr.array[idx + 2] +=
            (targetColors[idx + 2] - colAttr.array[idx + 2]) * lerpSpeed;

          // Add subtle idle noise/float
          if (currentGesture === "Open Hand") {
            posAttr.array[idx] += Math.sin(time + idx) * 0.01;
            posAttr.array[idx + 1] += Math.cos(time + idx) * 0.01;
          }
        }

        // Special Animation for Saturn Rings (Rotation)
        if (currentGesture === "Fist") {
          particles.rotation.y = time * 0.2;
          particles.rotation.z = Math.sin(time * 0.5) * 0.1;
        } else {
          // Reset rotation smoothly
          particles.rotation.y = THREE.MathUtils.lerp(
            particles.rotation.y,
            0,
            0.05
          );
          particles.rotation.z = THREE.MathUtils.lerp(
            particles.rotation.z,
            0,
            0.05
          );
        }

        posAttr.needsUpdate = true;
        colAttr.needsUpdate = true;

        composer.render();
      }

      // --- MediaPipe Hands ---
      function initMediaPipe() {
        const videoElement = document.getElementById("input-video");
        const previewElement = document.getElementById("webcam-preview");

        const hands = new Hands({
          locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
          },
        });

        hands.setOptions({
          maxNumHands: 1,
          modelComplexity: 1,
          minDetectionConfidence: 0.7,
          minTrackingConfidence: 0.7,
        });

        hands.onResults(onHandsResults);

        const cameraUtils = new Camera(videoElement, {
          onFrame: async () => {
            await hands.send({ image: videoElement });
          },
          width: 640,
          height: 480,
        });

        // Hook camera feed to preview
        navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
          videoElement.srcObject = stream;
          previewElement.srcObject = stream;
          cameraUtils.start();
        });
      }

      function onHandsResults(results) {
        if (
          results.multiHandLandmarks &&
          results.multiHandLandmarks.length > 0
        ) {
          const landmarks = results.multiHandLandmarks[0];
          detectGesture(landmarks);
        } else {
          // Default fallback
          if (currentGesture !== "None") {
            currentGesture = "None";
            updateUI("No Hand Detected", "gray");
            transitionToShape("sphere");
          }
        }
      }

      function detectGesture(lm) {
        // Helper: is finger extended? (tip y < pip y) - Note: y increases downwards in MediaPipe
        const isExtended = (tipIdx, pipIdx) => lm[tipIdx].y < lm[pipIdx].y;

        const thumbOpen = lm[4].x < lm[3].x; // Right hand assumption for simplicity (or check handedness)
        const indexOpen = isExtended(8, 6);
        const middleOpen = isExtended(12, 10);
        const ringOpen = isExtended(16, 14);
        const pinkyOpen = isExtended(20, 18);

        // Distance helper
        const dist = (i1, i2) =>
          Math.hypot(lm[i1].x - lm[i2].x, lm[i1].y - lm[i2].y);

        let newGesture = "";

        // 1. Pinch / V-Sign Logic (Thumb and Index tips close)
        if (dist(4, 8) < 0.05) {
          newGesture = "Pinch (Heart)";
          if (currentGesture !== newGesture) {
            transitionToShape("heart");
            updateUI(newGesture, "pink");
          }
        }
        // 2. Fist (All fingers folded)
        else if (!indexOpen && !middleOpen && !ringOpen && !pinkyOpen) {
          newGesture = "Fist";
          if (currentGesture !== newGesture) {
            transitionToShape("saturn");
            updateUI(newGesture, "blue");
          }
        }
        // 3. Pinky/Call Me (Thumb + Pinky Open, Middle+Ring Closed)
        else if (thumbOpen && pinkyOpen && !middleOpen && !ringOpen) {
          newGesture = "Call Me";
          if (currentGesture !== newGesture) {
            transitionToShape("text");
            updateUI(newGesture, "yellow");
          }
        }
        // 4. Open Hand (All open)
        else if (indexOpen && middleOpen && ringOpen && pinkyOpen) {
          newGesture = "Open Hand";
          if (currentGesture !== newGesture) {
            transitionToShape("sphere");
            updateUI(newGesture, "green");
          }
        }

        if (newGesture) currentGesture = newGesture;
      }

      function updateUI(text, colorClass) {
        gestureText.innerText = text;
        // Map simple color names to tailwind-ish hex or classes
        const map = {
          pink: "#ec4899",
          blue: "#3b82f6",
          yellow: "#eab308",
          green: "#22c55e",
          purple: "#a855f7",
          gray: "#6b7280",
        };
        gestureInd.style.backgroundColor = map[colorClass] || "white";
        gestureInd.style.boxShadow = `0 0 10px ${map[colorClass] || "white"}`;
      }

      // --- Utils ---
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
      }

      window.toggleFullScreen = function () {
        if (!document.fullscreenElement) {
          document.documentElement.requestFullscreen();
        } else {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          }
        }
      };

      // Start
      init();
    </script>
  </body>
</html>
